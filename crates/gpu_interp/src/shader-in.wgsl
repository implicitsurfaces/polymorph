// Autogenerated opcode constants$generated_prelude_goes_here

struct Bytecode {
    data: array<u32, 32768>,
}

struct FragmentOutput {
    @location(0) FragColor: vec4<f32>,
}

@group(0) @binding(0)
var<storage> bytecode: Bytecode;

@group(0) @binding(1)
var<uniform> pc_max: i32;

@group(0) @binding(2) var<storage, read_write> output: array<f32>;

@group(0) @binding(3) var<uniform> dims: vec2<u32>;

fn execute_bytecode(x: u32, y: u32) -> f32 {
    var pc: i32 = 0;
    var reg: array<f32, 255>;
    while (pc < pc_max) {
        /*
          Memory layout notes:
          - On the Rust side, the bytecode is seralized into a Vec<u8>. When
            we say "byte 0" or "first 4 bytes" we mean `bc_vec[0]` and
            `bc_vec[0..4]`, respectively.
          - Ops are 8 bytes long, with the first byte (i.e. `lo[0]`, below)
            being the opcode.
          - u8 arguments are generally packed into the 3 bytes following the
            opcode.
          - 32-bit arguments (u32 and f32) are stored in little-endian order
            in bytes 4-7.
          - Thus, `lo` is a 4xU8 while `hi` is a u32.
        */
        let lo: vec4<u32> = unpack4xU8(bytecode.data[pc]);
        pc++;
        let hi: f32 = bitcast<f32>(bytecode.data[pc]);
        pc++;

        switch (lo[0]) {
            case 0u /* Input */: {
              let out_reg = lo[1];
              let i = bitcast<u32>(hi);
              if (i == 0) {
                reg[out_reg] = f32(x);
              } else if (i == 1) {
                reg[out_reg] = f32(y);
              }
            }
            case 1u /* Output */: {
              let src_reg = lo[1];
              let i = bitcast<u32>(hi);
              if (i == 0) {
                return reg[src_reg];
              }
            }
            case 5u: /* SqrtReg */ {
              reg[lo[1]] = sqrt(reg[lo[2]]);
            }
            case 6u: /* SquareReg */ {
              let val = reg[lo[2]];
              reg[lo[1]] = val * val;
            }
            case 20u /* AddRegImm */: { reg[lo[1]] = reg[lo[2]] + hi; }
            case 24u /* SubImmReg */: { reg[lo[1]] = hi - reg[lo[2]]; }
            case 25u /* SubRegImm */: { reg[lo[1]] = reg[lo[2]] - hi; }
            case 38u /* AddRegReg */: { reg[lo[1]] = reg[lo[2]] + reg[lo[3]]; }
            case 42u /* MinRegReg */: { reg[lo[1]] = min(reg[lo[2]], reg[lo[3]]); }
            default: {
              return 1.234567;
            }
          }
    }
    return 2.0;
}

@compute
@workgroup_size(16, 16)
fn compute_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let index = global_id.y * dims.x + global_id.x;
    output[index] = execute_bytecode(global_id.x, global_id.y);
}
