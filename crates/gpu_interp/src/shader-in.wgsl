// Autogenerated opcode constants$generated_prelude_goes_here

struct Bytecode {
    data: array<u32, 2048>,
}

struct FragmentOutput {
    @location(0) FragColor: vec4<f32>,
}

@group(0) @binding(0)
var<storage> bytecode: Bytecode;

@group(0) @binding(1)
var<uniform> bytecode_length: i32;

@group(0) @binding(2) var<storage, read_write> output: array<f32>;

@group(0) @binding(3) var<uniform> dims: vec2<u32>;

fn execute_bytecode(x: u32, y: u32) -> f32 {
    var pc: i32 = 0;
    var reg: array<f32, 255>;
    while (pc < bytecode_length) {
        let lo: vec4<u32> = unpack4xU8(bytecode.data[pc]);
        pc++;
        let hi: u32 = bytecode.data[pc];
        pc++;

        switch (lo[0]) {
            case 0u /* Input */: {
              let out_reg = lo[1];
              let i = u32(hi);
              if (i == 0) {
                reg[out_reg] = f32(x);
              } else if (i == 1) {
                reg[out_reg] = f32(y);
              }
            }
            case 1u /* Output */: {
              let src_reg = lo[1];
              let i = u32(hi);
              if (i == 0) {
                return reg[src_reg];
              }
            }
            case 20u /* AddRegImm  */: {
              let out_reg = lo[1];
              let arg_reg = lo[2];
              let imm = bitcast<f32>(hi);
              reg[out_reg] = reg[arg_reg] + imm;
            }
            default: {
              return 1.23456789;
            }
          }
    }
    return 2.0;
}

@compute
@workgroup_size(4, 4)
fn compute_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let index = global_id.y * dims.x + global_id.x;
    output[index] = execute_bytecode(global_id.x, global_id.y);
}
