// Autogenerated opcode constants$generated_prelude_goes_here

struct Bytecode {
    data: array<u32, 1024>,
}

struct FragmentOutput {
    @location(0) FragColor: vec4<f32>,
}

@group(0) @binding(0)
var<storage> bytecode: Bytecode;

@group(0) @binding(1)
var<uniform> bytecode_length: i32;

@group(0) @binding(2) var<storage, read_write> output: array<f32>;

@group(0) @binding(3) var<uniform> dimensions: vec2<u32>;

fn execute_bytecode(x: i32, y: i32) -> f32 {
    var color: vec4<f32> = vec4(0f);
    var pc: i32 = 0i;
    var stack: array<f32, 64>;
    var sp: i32 = 0i;
    // var op: i32;
    // var value: i32;
    // var id: i32;
    var is_inside: f32;

    while (pc < bytecode_length) {
        var op: u32 = bytecode.data[pc];
        pc++;

        switch (op) {
            case OP_ADD: {
                sp--;
                stack[sp - 1] = stack[sp - 1] + stack[sp];
                break;
            }
            case OP_SUB: {
                sp--;
                stack[sp - 1] = stack[sp - 1] - stack[sp];
                break;
            }
            case OP_MUL: {
                sp--;
                stack[sp - 1] = stack[sp - 1] * stack[sp];
                break;
            }
            case OP_PUSH_I32: {
                var value: f32 = f32(bytecode.data[pc]);
                pc++;
                stack[sp] = value;
                sp++;
                break;
            }
            case OP_PARAM: {
                var id: u32 = bytecode.data[pc];
                pc++;
                if (id == 0u) {
                    stack[sp] = f32(x);
                } else if (id == 1u) {
                    stack[sp] = f32(y);
                }
                sp++;
                break;
            }
            case OP_SQRT: {
                stack[sp - 1] = sqrt(stack[sp - 1]);
                break;
            }
            case OP_SIGMOID: {
                stack[sp - 1] = 1.0 / (1.0 + exp(-stack[sp - 1]));
                break;
            }
            case OP_DEBUG_RETURN_TOS: {
                return stack[sp-1];
            }
            case OP_DEBUG_RETURN_SP: {
                return f32(sp);
            }
            case OP_DROP: {
                sp--;
                break;
            }
            default: {
            }
        }
    }
    return stack[sp - 1];
}

@compute
@workgroup_size(4, 4)
fn compute_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let width = dimensions.x;
    let height = dimensions.y;
    let index = global_id.y * width + global_id.x;
    output[index] = execute_bytecode(i32(global_id.x), i32(global_id.y));
}

@fragment
fn fragment_main(@builtin(position) pos: vec4<f32>) -> FragmentOutput {
    var result = execute_bytecode(i32(pos.x), i32(pos.y));
    return FragmentOutput(vec4<f32>(result, result, result, 1.0));
}
