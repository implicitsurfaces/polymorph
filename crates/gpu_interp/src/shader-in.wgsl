// Autogenerated opcode constants$generated_prelude_goes_here

struct Bytecode {
    data: array<u64, 1024>,
}

struct FragmentOutput {
    @location(0) FragColor: vec4<f32>,
}

@group(0) @binding(0)
var<storage> bytecode: Bytecode;

@group(0) @binding(1)
var<uniform> bytecode_length: i32;

@group(0) @binding(2) var<storage, read_write> output: array<f32>;

@group(0) @binding(3) var<uniform> dimensions: vec2<u32>;

fn execute_bytecode(x: i32, y: i32) -> f32 {
    var pc: i32 = 0i;
    var ret: f32 = 0.0;

    while (pc < bytecode_length) {
        let op: u64 = bytecode.data[pc];
        let opcode: u32 = u32((op >> 56) & u64(0xFF));
        // Arguments, in order, are
        // - Output register
        // - LHS register (or input slot for [`Input`](RegOp::Input))
        // - RHS register (or immediate for `*Imm`)
        let output = i32((op >> 48) & u64(0xFF));
        let lhs = i32((op >> 40) & u64(0xFF));
        let rhs = i32((op >> 32) & u64(0xFF));

        switch (opcode) {
            case 0u: {
            }
            default: {
              // ret += f32(opcode);
              return f32(op);
            }
          }
          pc += 1;
    }
    // return f32(bytecode_length);
    return ret;
}

@compute
@workgroup_size(4, 4)
fn compute_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let width = dimensions.x;
    let height = dimensions.y;
    let index = global_id.y * width + global_id.x;
    output[index] = execute_bytecode(i32(global_id.x), i32(global_id.y));
}
